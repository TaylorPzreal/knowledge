---
title: "1st"
# weight: 1
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# 第一篇

Review
1. 2019/07/23

时时勤拂拭，勿使惹尘埃。

解释
在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构，提高其可理解性，降低其修改成本。

识别坏味道、测试先行、行为保持的变更动作，是重构的基本功。

重构16字心法:
- 旧的不变
- 新的创建
- 一步切换
- 旧的再见

如果你要给程序添加一个特性 ，但发现代码因缺乏良好的结构而不易于进行修改，那就先重构那个程序，使其比较容易添加该特性，然后再添加。

## 【Why】为何重构？
	重构的唯一目的就是让我们开发更快 —— 添加新功能更快，修复bug更快。让企业快速迭代并获得最大利益。具体而言：
- 重构改进软件的设计（消除无用代码、消除重复代码）
- 重构使软件更容易理解（让以后的自己和他人更容易理解）
- 重构帮助找到bug（好的代码更容易找到问题）
- 重构提高编程速度

不可能一开始就能有一个完美无缺的设计，我们只能先有一个差不多的设计，然后迭代，重构改进。

## 【What】重构什么？代码的坏味道
1. 神秘命名(Mysterious Name) 缩写、中文拼音、错词、单复数、规范（驼峰）
2. 重复代码(Duplicated Code)
3. 过长函数(Long Function)
4. 过长参数列表（Long Parameter List）
5. 全局数据（Global Data）
6. 可变数据（Mutable Data）-> 函数式编程
7. 发散式变化（Divergent Change）某模块因需求在不同方向上发生变化 -> 拆分功能
8. 散弹式修改（Shotgun Surgery）某种变化，必须在许多不同的类内做出许多小修改 -> 内联
9. 依恋情结（Feature Envy）一个函数跟另一个模块的函数交流格外频繁，远胜于在自己所处模块内部的交流 -> 搬移函数
10. 数据泥团（Data Clumps）两个类中相同的字段，许多函数中相同的参数
11. 基本类型偏执（Primitive Obsession）一组总是同时出现的基本类型数据 -> 提炼类、引入参数对象
12. 重复的Switch（Repeated Switches）->以多态取代条件表达式
13. 循环语句（Loops）-> 以管道取代循环 filter、map、same…
14. 冗赘的元素（Lazy Element）不再被需要的代码
15. 夸夸其谈通用型（Speculative Generality） 过分设计
16. 临时字段（Temporary Field）针对特定情况的字段
17. 过长的消息链（Message Chains）一长串取值函数（一个对象请求另一个对象，后者再请求另一个对象）
18. 中间人（Middle Man）过度运用委托，某个类的接口有一半的函数都委托给了其他类 -> 移除中间人
19. 内幕交易（Insider Trading）模块之间大量交换数据
20. 过大的类（Large Class）提炼类、提炼超类、以子类取代类型码
21. 异曲同工的类（Alternative Classes with Different Interfaces）
22. 纯数据类（Data Class）
23. 被拒绝的遗赠（Refused Bequest）
24. 注释（Comments）当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。

## 【When】何时重构
事不过三，三则重构。

见机行事的重构：
- 预备性重构：让添加新功能更容易（添加新功能前、修复bug前先去看下老代码）
- 帮助理解的重构：使代码更易懂（函数命名，变量命名、长函数拆离）
- 捡垃圾式重构

有计划的重构：
	重构并不是人们为了弥补过去的错误或者清理肮脏的代码。当然，肮脏的代码必须重构，但漂亮的代码，也需要很多重构。
- 长期重构（库升级替换、原来设计过于差）
- 代码复审（Code Review）时重构

何时不应该重构
- 当下工作的内容与他无关、不需要理解其原理
- 重写比重构还容易

## 【Who】
Every coder

## 重构的挑战
- 延缓新功能开发（很普遍的看法，“重构会拖慢进度”，论点一定要从经济利益出发，重构的唯一目的就是让我们开发更快 —— 添加新功能更快，修复bug更快）
- 代码所有权（比如已发布接口，声明者无权修改使用者的代码）
- 分支（特性分支、持续集成（Continuous Integration CI）也叫基于主干开发Trunk Based Development），确保主线随时处于健康状态，将大功能拆解成小功能，要使用特性开关（feature toggle，也叫特性旗标 feature flag）将尚未完成的又无法拆小的功能隐藏掉。
- 测试，毫不意外，自测试代码与持续集成紧密相关 ——— 我们依赖持续集成来及时捕获分支集成时的语义冲突。自测试代码是极限编程的另一个重要组成部分，也是持续交付的关键环节。
- 遗留代码，请看书籍《修改代码的艺术》，一言以蔽之，他建议你先找到程序的接缝，在接缝处插入测试，如此将系统置于测试覆盖之下。
- 数据库重构，小步完整修改。并行修改（Parallel Change）

## 【How】如何重构
重构前，先检查自己是否有一套可靠的测试集，这些测试必须有自我检验能力。
每当我要进行重构的时候，第一个步骤永远相同：确保即将修改的代码拥有一组可靠的测试。
重构技术就是以微小的步伐修改程序，任何改动后，马上编译并执行一遍测试，养成重构后即运行测试的习惯非常重要。重构 -> 编译 -> 提交。
方法论：
- 提炼函数
- 函数命名，如果是求返回值，可以命名result
- 参数都带上类型，不定冠词，单复数
- 以查询取代临时变量
- 内联函数
- 改变函数声明
- 拆分阶段
- 搬移函数
- 以管道取代循环
- 以多态取代条件表达式


重构、架构、YAGNI
策略：简单设计、增量式设计或YAGNI（you aren’t going to need it）

## 构筑测试体系
测试驱动开发（Test-Driven Development, TDD）
选择一个优秀的自测试框架（Jest、mocha）

编写测试流程：
先编写一个（失败的）测试，编写功能代码使测试通过，然后重构，以保证代码整洁。即测试 -> 编码 -> 重构

要点：
- describe和it块里面描述信息不需多写
- 添加测试遵循的风格：观察被测试类应该做的所有事情，然后对这个类的每个行为进行测试，包括各种使它发生异常的边界条件。
- 测试的重点应该是那些最担心出错的部分，火力集中在可能出错的地方，这样就能从测试工作中得到最大利益。
- 共享测试夹具，务必小心，确保没有测试会去更改他。最好将其放在beforeEach里面声明，这样每个测试拿到的都是新的独立的数据。
- 一个it语句最好只有一个验证语句，当然多个相关的也允许放在一起。
- 测试边界条件：0、负值、null、undefined、类型不一致
- 每当你收到bug报告，先写一个单元测试来暴露这个 bug。
- 测试覆盖率的分析只能识别出那些未被测试覆盖到的代码，而不能用来衡量一个测试集的质量高低。

测试3阶段：
配置 - 检查 - 验证（setup-exercise-verify）或 准备 - 行为 - 断言（arrange-act-assert）
第四阶段是 拆除阶段，用于将测试夹具移除，确保不同测试间不会产生交互。

## 重构2采用的记录格式
- 名称（name）
- 速写（sketch）帮助你更快找到所需要的重构手法
- 动机（motivation）
- 做法（mechanics）
- 范例（examples）

## 经典语录
* 在VUCA（易变，不确定，复杂，模糊）环境下，重构极其重要。
* 至少要让营地比我到达时更干净。
* 要真正的以敏捷的方式运作项目，团队成员必须在重构上有能力、有热情，他们采用的开发过程必须与常规的、持续的重构相匹配。
* 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。
* 好代码的检验标准就是人们是否能轻而易举地修改它。


## 参考
http://www.informit.com/

Web版本
https://memberservices.informit.com/my_account/webedition/9780135425664/html/toc.html

## 延展阅读
- 《重构手册》
- 《重构与模式》
- 《数据库重构》
- 《重构HTML》
- 《修改代码的艺术》
